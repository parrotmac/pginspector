// Code generated by pggen. DO NOT EDIT.

package validation

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

// Querier is a typesafe Go interface backed by SQL queries.
type Querier interface {
	SelectManufacturerByID(ctx context.Context, id uuid.UUID) (SelectManufacturerByIDRow, error)

	SelectManufacturerList(ctx context.Context) ([]SelectManufacturerListRow, error)

	SelectVehicleByID(ctx context.Context, id uuid.UUID) (SelectVehicleByIDRow, error)

	SelectVehicleList(ctx context.Context) ([]SelectVehicleListRow, error)

	SelectModelByID(ctx context.Context, id uuid.UUID) (SelectModelByIDRow, error)

	SelectModelList(ctx context.Context) ([]SelectModelListRow, error)

	SelectPersonByID(ctx context.Context, id uuid.UUID) (SelectPersonByIDRow, error)

	SelectPersonList(ctx context.Context) ([]SelectPersonListRow, error)

	SelectRentalByID(ctx context.Context, id uuid.UUID) (SelectRentalByIDRow, error)

	SelectRentalList(ctx context.Context) ([]SelectRentalListRow, error)

	SelectOwnershipByID(ctx context.Context, id uuid.UUID) (SelectOwnershipByIDRow, error)

	SelectOwnershipList(ctx context.Context) ([]SelectOwnershipListRow, error)

	UpdateManufacturer(ctx context.Context, params UpdateManufacturerParams) (UpdateManufacturerRow, error)

	UpdateManufacturerFieldMask(ctx context.Context, params UpdateManufacturerFieldMaskParams) (UpdateManufacturerFieldMaskRow, error)

	UpdateVehicle(ctx context.Context, params UpdateVehicleParams) (UpdateVehicleRow, error)

	UpdateVehicleFieldMask(ctx context.Context, params UpdateVehicleFieldMaskParams) (UpdateVehicleFieldMaskRow, error)

	UpdateModel(ctx context.Context, params UpdateModelParams) (UpdateModelRow, error)

	UpdateModelFieldMask(ctx context.Context, params UpdateModelFieldMaskParams) (UpdateModelFieldMaskRow, error)

	UpdatePerson(ctx context.Context, params UpdatePersonParams) (UpdatePersonRow, error)

	UpdatePersonFieldMask(ctx context.Context, params UpdatePersonFieldMaskParams) (UpdatePersonFieldMaskRow, error)

	UpdateRental(ctx context.Context, params UpdateRentalParams) (UpdateRentalRow, error)

	UpdateRentalFieldMask(ctx context.Context, params UpdateRentalFieldMaskParams) (UpdateRentalFieldMaskRow, error)

	UpdateOwnership(ctx context.Context, params UpdateOwnershipParams) (UpdateOwnershipRow, error)

	UpdateOwnershipFieldMask(ctx context.Context, params UpdateOwnershipFieldMaskParams) (UpdateOwnershipFieldMaskRow, error)
}

type DBQuerier struct {
	conn  genericConn   // underlying Postgres transport to use
	types *typeResolver // resolve types by name
}

var _ Querier = &DBQuerier{}

// genericConn is a connection to a Postgres database. This is usually backed by
// *pgx.Conn, pgx.Tx, or *pgxpool.Pool.
type genericConn interface {
	// Query executes sql with args. If there is an error the returned Rows will
	// be returned in an error state. So it is allowed to ignore the error
	// returned from Query and handle it in Rows.
	Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error)

	// QueryRow is a convenience wrapper over Query. Any error that occurs while
	// querying is deferred until calling Scan on the returned Row. That Row will
	// error with pgx.ErrNoRows if no rows are returned.
	QueryRow(ctx context.Context, sql string, args ...interface{}) pgx.Row

	// Exec executes sql. sql can be either a prepared statement name or an SQL
	// string. arguments should be referenced positionally from the sql string
	// as $1, $2, etc.
	Exec(ctx context.Context, sql string, arguments ...interface{}) (pgconn.CommandTag, error)
}

// NewQuerier creates a DBQuerier that implements Querier. conn is typically
// *pgx.Conn, pgx.Tx, or *pgxpool.Pool.
func NewQuerier(conn genericConn) *DBQuerier {
	return &DBQuerier{conn: conn, types: newTypeResolver()}
}

// WithTx creates a new DBQuerier that uses the transaction to run all queries.
func (q *DBQuerier) WithTx(tx pgx.Tx) (*DBQuerier, error) {
	return &DBQuerier{conn: tx}, nil
}

// typeResolver looks up the pgtype.ValueTranscoder by Postgres type name.
type typeResolver struct {
	connInfo *pgtype.ConnInfo // types by Postgres type name
}

func newTypeResolver() *typeResolver {
	ci := pgtype.NewConnInfo()
	return &typeResolver{connInfo: ci}
}

// findValue find the OID, and pgtype.ValueTranscoder for a Postgres type name.
func (tr *typeResolver) findValue(name string) (uint32, pgtype.ValueTranscoder, bool) {
	typ, ok := tr.connInfo.DataTypeForName(name)
	if !ok {
		return 0, nil, false
	}
	v := pgtype.NewValue(typ.Value)
	return typ.OID, v.(pgtype.ValueTranscoder), true
}

// setValue sets the value of a ValueTranscoder to a value that should always
// work and panics if it fails.
func (tr *typeResolver) setValue(vt pgtype.ValueTranscoder, val interface{}) pgtype.ValueTranscoder {
	if err := vt.Set(val); err != nil {
		panic(fmt.Sprintf("set ValueTranscoder %T to %+v: %s", vt, val, err))
	}
	return vt
}

const selectManufacturerByIDSQL = `SELECT
	created_at,
	id,
	name,
	updated_at
FROM public.manufacturer
WHERE id = $1;`

type SelectManufacturerByIDRow struct {
	CreatedAt *time.Time `json:"created_at"`
	ID        uuid.UUID  `json:"id"`
	Name      *string    `json:"name"`
	UpdatedAt *time.Time `json:"updated_at"`
}

// SelectManufacturerByID implements Querier.SelectManufacturerByID.
func (q *DBQuerier) SelectManufacturerByID(ctx context.Context, id uuid.UUID) (SelectManufacturerByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "SelectManufacturerByID")
	row := q.conn.QueryRow(ctx, selectManufacturerByIDSQL, id)
	var item SelectManufacturerByIDRow
	if err := row.Scan(&item.CreatedAt, &item.ID, &item.Name, &item.UpdatedAt); err != nil {
		return item, fmt.Errorf("query SelectManufacturerByID: %w", err)
	}
	return item, nil
}

const selectManufacturerListSQL = `SELECT
	created_at,
	id,
	name,
	updated_at
FROM public.manufacturer;`

type SelectManufacturerListRow struct {
	CreatedAt *time.Time `json:"created_at"`
	ID        uuid.UUID  `json:"id"`
	Name      *string    `json:"name"`
	UpdatedAt *time.Time `json:"updated_at"`
}

// SelectManufacturerList implements Querier.SelectManufacturerList.
func (q *DBQuerier) SelectManufacturerList(ctx context.Context) ([]SelectManufacturerListRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "SelectManufacturerList")
	rows, err := q.conn.Query(ctx, selectManufacturerListSQL)
	if err != nil {
		return nil, fmt.Errorf("query SelectManufacturerList: %w", err)
	}
	defer rows.Close()
	items := []SelectManufacturerListRow{}
	for rows.Next() {
		var item SelectManufacturerListRow
		if err := rows.Scan(&item.CreatedAt, &item.ID, &item.Name, &item.UpdatedAt); err != nil {
			return nil, fmt.Errorf("scan SelectManufacturerList row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close SelectManufacturerList rows: %w", err)
	}
	return items, err
}

const selectVehicleByIDSQL = `SELECT
	created_at,
	id,
	make,
	model,
	updated_at,
	vin,
	year
FROM public.vehicle
WHERE id = $1;`

type SelectVehicleByIDRow struct {
	CreatedAt *time.Time `json:"created_at"`
	ID        uuid.UUID  `json:"id"`
	Make      uuid.UUID  `json:"make"`
	Model     uuid.UUID  `json:"model"`
	UpdatedAt *time.Time `json:"updated_at"`
	Vin       *string    `json:"vin"`
	Year      int32      `json:"year"`
}

// SelectVehicleByID implements Querier.SelectVehicleByID.
func (q *DBQuerier) SelectVehicleByID(ctx context.Context, id uuid.UUID) (SelectVehicleByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "SelectVehicleByID")
	row := q.conn.QueryRow(ctx, selectVehicleByIDSQL, id)
	var item SelectVehicleByIDRow
	if err := row.Scan(&item.CreatedAt, &item.ID, &item.Make, &item.Model, &item.UpdatedAt, &item.Vin, &item.Year); err != nil {
		return item, fmt.Errorf("query SelectVehicleByID: %w", err)
	}
	return item, nil
}

const selectVehicleListSQL = `SELECT
	created_at,
	id,
	make,
	model,
	updated_at,
	vin,
	year
FROM public.vehicle;`

type SelectVehicleListRow struct {
	CreatedAt *time.Time `json:"created_at"`
	ID        uuid.UUID  `json:"id"`
	Make      uuid.UUID  `json:"make"`
	Model     uuid.UUID  `json:"model"`
	UpdatedAt *time.Time `json:"updated_at"`
	Vin       *string    `json:"vin"`
	Year      *int32     `json:"year"`
}

// SelectVehicleList implements Querier.SelectVehicleList.
func (q *DBQuerier) SelectVehicleList(ctx context.Context) ([]SelectVehicleListRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "SelectVehicleList")
	rows, err := q.conn.Query(ctx, selectVehicleListSQL)
	if err != nil {
		return nil, fmt.Errorf("query SelectVehicleList: %w", err)
	}
	defer rows.Close()
	items := []SelectVehicleListRow{}
	for rows.Next() {
		var item SelectVehicleListRow
		if err := rows.Scan(&item.CreatedAt, &item.ID, &item.Make, &item.Model, &item.UpdatedAt, &item.Vin, &item.Year); err != nil {
			return nil, fmt.Errorf("scan SelectVehicleList row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close SelectVehicleList rows: %w", err)
	}
	return items, err
}

const selectModelByIDSQL = `SELECT
	created_at,
	id,
	name,
	updated_at
FROM public.model
WHERE id = $1;`

type SelectModelByIDRow struct {
	CreatedAt *time.Time `json:"created_at"`
	ID        uuid.UUID  `json:"id"`
	Name      *string    `json:"name"`
	UpdatedAt *time.Time `json:"updated_at"`
}

// SelectModelByID implements Querier.SelectModelByID.
func (q *DBQuerier) SelectModelByID(ctx context.Context, id uuid.UUID) (SelectModelByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "SelectModelByID")
	row := q.conn.QueryRow(ctx, selectModelByIDSQL, id)
	var item SelectModelByIDRow
	if err := row.Scan(&item.CreatedAt, &item.ID, &item.Name, &item.UpdatedAt); err != nil {
		return item, fmt.Errorf("query SelectModelByID: %w", err)
	}
	return item, nil
}

const selectModelListSQL = `SELECT
	created_at,
	id,
	name,
	updated_at
FROM public.model;`

type SelectModelListRow struct {
	CreatedAt *time.Time `json:"created_at"`
	ID        uuid.UUID  `json:"id"`
	Name      *string    `json:"name"`
	UpdatedAt *time.Time `json:"updated_at"`
}

// SelectModelList implements Querier.SelectModelList.
func (q *DBQuerier) SelectModelList(ctx context.Context) ([]SelectModelListRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "SelectModelList")
	rows, err := q.conn.Query(ctx, selectModelListSQL)
	if err != nil {
		return nil, fmt.Errorf("query SelectModelList: %w", err)
	}
	defer rows.Close()
	items := []SelectModelListRow{}
	for rows.Next() {
		var item SelectModelListRow
		if err := rows.Scan(&item.CreatedAt, &item.ID, &item.Name, &item.UpdatedAt); err != nil {
			return nil, fmt.Errorf("scan SelectModelList row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close SelectModelList rows: %w", err)
	}
	return items, err
}

const selectPersonByIDSQL = `SELECT
	created_at,
	id,
	name,
	updated_at
FROM public.person
WHERE id = $1;`

type SelectPersonByIDRow struct {
	CreatedAt *time.Time `json:"created_at"`
	ID        uuid.UUID  `json:"id"`
	Name      *string    `json:"name"`
	UpdatedAt *time.Time `json:"updated_at"`
}

// SelectPersonByID implements Querier.SelectPersonByID.
func (q *DBQuerier) SelectPersonByID(ctx context.Context, id uuid.UUID) (SelectPersonByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "SelectPersonByID")
	row := q.conn.QueryRow(ctx, selectPersonByIDSQL, id)
	var item SelectPersonByIDRow
	if err := row.Scan(&item.CreatedAt, &item.ID, &item.Name, &item.UpdatedAt); err != nil {
		return item, fmt.Errorf("query SelectPersonByID: %w", err)
	}
	return item, nil
}

const selectPersonListSQL = `SELECT
	created_at,
	id,
	name,
	updated_at
FROM public.person;`

type SelectPersonListRow struct {
	CreatedAt *time.Time `json:"created_at"`
	ID        uuid.UUID  `json:"id"`
	Name      *string    `json:"name"`
	UpdatedAt *time.Time `json:"updated_at"`
}

// SelectPersonList implements Querier.SelectPersonList.
func (q *DBQuerier) SelectPersonList(ctx context.Context) ([]SelectPersonListRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "SelectPersonList")
	rows, err := q.conn.Query(ctx, selectPersonListSQL)
	if err != nil {
		return nil, fmt.Errorf("query SelectPersonList: %w", err)
	}
	defer rows.Close()
	items := []SelectPersonListRow{}
	for rows.Next() {
		var item SelectPersonListRow
		if err := rows.Scan(&item.CreatedAt, &item.ID, &item.Name, &item.UpdatedAt); err != nil {
			return nil, fmt.Errorf("scan SelectPersonList row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close SelectPersonList rows: %w", err)
	}
	return items, err
}

const selectRentalByIDSQL = `SELECT
	created_at,
	end_date,
	id,
	start_date,
	updated_at,
	vehicle
FROM public.rental
WHERE id = $1;`

type SelectRentalByIDRow struct {
	CreatedAt *time.Time `json:"created_at"`
	EndDate   *time.Time `json:"end_date"`
	ID        uuid.UUID  `json:"id"`
	StartDate *time.Time `json:"start_date"`
	UpdatedAt *time.Time `json:"updated_at"`
	Vehicle   uuid.UUID  `json:"vehicle"`
}

// SelectRentalByID implements Querier.SelectRentalByID.
func (q *DBQuerier) SelectRentalByID(ctx context.Context, id uuid.UUID) (SelectRentalByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "SelectRentalByID")
	row := q.conn.QueryRow(ctx, selectRentalByIDSQL, id)
	var item SelectRentalByIDRow
	if err := row.Scan(&item.CreatedAt, &item.EndDate, &item.ID, &item.StartDate, &item.UpdatedAt, &item.Vehicle); err != nil {
		return item, fmt.Errorf("query SelectRentalByID: %w", err)
	}
	return item, nil
}

const selectRentalListSQL = `SELECT
	created_at,
	end_date,
	id,
	start_date,
	updated_at,
	vehicle
FROM public.rental;`

type SelectRentalListRow struct {
	CreatedAt *time.Time `json:"created_at"`
	EndDate   *time.Time `json:"end_date"`
	ID        uuid.UUID  `json:"id"`
	StartDate *time.Time `json:"start_date"`
	UpdatedAt *time.Time `json:"updated_at"`
	Vehicle   uuid.UUID  `json:"vehicle"`
}

// SelectRentalList implements Querier.SelectRentalList.
func (q *DBQuerier) SelectRentalList(ctx context.Context) ([]SelectRentalListRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "SelectRentalList")
	rows, err := q.conn.Query(ctx, selectRentalListSQL)
	if err != nil {
		return nil, fmt.Errorf("query SelectRentalList: %w", err)
	}
	defer rows.Close()
	items := []SelectRentalListRow{}
	for rows.Next() {
		var item SelectRentalListRow
		if err := rows.Scan(&item.CreatedAt, &item.EndDate, &item.ID, &item.StartDate, &item.UpdatedAt, &item.Vehicle); err != nil {
			return nil, fmt.Errorf("scan SelectRentalList row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close SelectRentalList rows: %w", err)
	}
	return items, err
}

const selectOwnershipByIDSQL = `SELECT
	created_at,
	end_date,
	id,
	person,
	start_date,
	updated_at,
	vehicle
FROM public.ownership
WHERE id = $1;`

type SelectOwnershipByIDRow struct {
	CreatedAt *time.Time `json:"created_at"`
	EndDate   *time.Time `json:"end_date"`
	ID        uuid.UUID  `json:"id"`
	Person    uuid.UUID  `json:"person"`
	StartDate *time.Time `json:"start_date"`
	UpdatedAt *time.Time `json:"updated_at"`
	Vehicle   uuid.UUID  `json:"vehicle"`
}

// SelectOwnershipByID implements Querier.SelectOwnershipByID.
func (q *DBQuerier) SelectOwnershipByID(ctx context.Context, id uuid.UUID) (SelectOwnershipByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "SelectOwnershipByID")
	row := q.conn.QueryRow(ctx, selectOwnershipByIDSQL, id)
	var item SelectOwnershipByIDRow
	if err := row.Scan(&item.CreatedAt, &item.EndDate, &item.ID, &item.Person, &item.StartDate, &item.UpdatedAt, &item.Vehicle); err != nil {
		return item, fmt.Errorf("query SelectOwnershipByID: %w", err)
	}
	return item, nil
}

const selectOwnershipListSQL = `SELECT
	created_at,
	end_date,
	id,
	person,
	start_date,
	updated_at,
	vehicle
FROM public.ownership;`

type SelectOwnershipListRow struct {
	CreatedAt *time.Time `json:"created_at"`
	EndDate   *time.Time `json:"end_date"`
	ID        uuid.UUID  `json:"id"`
	Person    uuid.UUID  `json:"person"`
	StartDate *time.Time `json:"start_date"`
	UpdatedAt *time.Time `json:"updated_at"`
	Vehicle   uuid.UUID  `json:"vehicle"`
}

// SelectOwnershipList implements Querier.SelectOwnershipList.
func (q *DBQuerier) SelectOwnershipList(ctx context.Context) ([]SelectOwnershipListRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "SelectOwnershipList")
	rows, err := q.conn.Query(ctx, selectOwnershipListSQL)
	if err != nil {
		return nil, fmt.Errorf("query SelectOwnershipList: %w", err)
	}
	defer rows.Close()
	items := []SelectOwnershipListRow{}
	for rows.Next() {
		var item SelectOwnershipListRow
		if err := rows.Scan(&item.CreatedAt, &item.EndDate, &item.ID, &item.Person, &item.StartDate, &item.UpdatedAt, &item.Vehicle); err != nil {
			return nil, fmt.Errorf("scan SelectOwnershipList row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close SelectOwnershipList rows: %w", err)
	}
	return items, err
}

const updateManufacturerSQL = `UPDATE public.manufacturer
SET (
	created_at,
	id,
	name,
	updated_at
) = (
	$1,
	$2,
	$3,
	$4
) WHERE id = $2 RETURNING *;`

type UpdateManufacturerParams struct {
	CreatedAt *time.Time `json:"created_at"`
	ID        uuid.UUID  `json:"id"`
	Name      *string    `json:"name"`
	UpdatedAt *time.Time `json:"updated_at"`
}

type UpdateManufacturerRow struct {
	ID        uuid.UUID  `json:"id"`
	Name      *string    `json:"name"`
	CreatedAt *time.Time `json:"created_at"`
	UpdatedAt *time.Time `json:"updated_at"`
}

// UpdateManufacturer implements Querier.UpdateManufacturer.
func (q *DBQuerier) UpdateManufacturer(ctx context.Context, params UpdateManufacturerParams) (UpdateManufacturerRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateManufacturer")
	row := q.conn.QueryRow(ctx, updateManufacturerSQL, params.CreatedAt, params.ID, params.Name, params.UpdatedAt)
	var item UpdateManufacturerRow
	if err := row.Scan(&item.ID, &item.Name, &item.CreatedAt, &item.UpdatedAt); err != nil {
		return item, fmt.Errorf("query UpdateManufacturer: %w", err)
	}
	return item, nil
}

const updateManufacturerFieldMaskSQL = `UPDATE public.manufacturer
SET (
	created_at,
	id,
	name,
	updated_at
) = (
	CASE
		WHEN 'created_at' = ANY($1::text[]) THEN $2
		ELSE created_at
	END,
	CASE
		WHEN 'id' = ANY($1::text[]) THEN $3
		ELSE id
	END,
	CASE
		WHEN 'name' = ANY($1::text[]) THEN $4
		ELSE name
	END,
	CASE
		WHEN 'updated_at' = ANY($1::text[]) THEN $5
		ELSE updated_at
	END
) WHERE id = $3 RETURNING *;`

type UpdateManufacturerFieldMaskParams struct {
	FieldMask []string   `json:"_field_mask"`
	CreatedAt *time.Time `json:"created_at"`
	ID        uuid.UUID  `json:"id"`
	Name      *string    `json:"name"`
	UpdatedAt *time.Time `json:"updated_at"`
}

type UpdateManufacturerFieldMaskRow struct {
	ID        uuid.UUID  `json:"id"`
	Name      *string    `json:"name"`
	CreatedAt *time.Time `json:"created_at"`
	UpdatedAt *time.Time `json:"updated_at"`
}

// UpdateManufacturerFieldMask implements Querier.UpdateManufacturerFieldMask.
func (q *DBQuerier) UpdateManufacturerFieldMask(ctx context.Context, params UpdateManufacturerFieldMaskParams) (UpdateManufacturerFieldMaskRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateManufacturerFieldMask")
	row := q.conn.QueryRow(ctx, updateManufacturerFieldMaskSQL, params.FieldMask, params.CreatedAt, params.ID, params.Name, params.UpdatedAt)
	var item UpdateManufacturerFieldMaskRow
	if err := row.Scan(&item.ID, &item.Name, &item.CreatedAt, &item.UpdatedAt); err != nil {
		return item, fmt.Errorf("query UpdateManufacturerFieldMask: %w", err)
	}
	return item, nil
}

const updateVehicleSQL = `UPDATE public.vehicle
SET (
	created_at,
	id,
	make,
	model,
	updated_at,
	vin,
	year
) = (
	$1,
	$2,
	$3,
	$4,
	$5,
	$6,
	$7
) WHERE id = $2 RETURNING *;`

type UpdateVehicleParams struct {
	CreatedAt *time.Time `json:"created_at"`
	ID        uuid.UUID  `json:"id"`
	Make      uuid.UUID  `json:"make"`
	Model     uuid.UUID  `json:"model"`
	UpdatedAt *time.Time `json:"updated_at"`
	Vin       *string    `json:"vin"`
	Year      int32      `json:"year"`
}

type UpdateVehicleRow struct {
	ID        uuid.UUID  `json:"id"`
	CreatedAt *time.Time `json:"created_at"`
	UpdatedAt *time.Time `json:"updated_at"`
	Make      uuid.UUID  `json:"make"`
	Model     uuid.UUID  `json:"model"`
	Year      int32      `json:"year"`
	Vin       *string    `json:"vin"`
}

// UpdateVehicle implements Querier.UpdateVehicle.
func (q *DBQuerier) UpdateVehicle(ctx context.Context, params UpdateVehicleParams) (UpdateVehicleRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateVehicle")
	row := q.conn.QueryRow(ctx, updateVehicleSQL, params.CreatedAt, params.ID, params.Make, params.Model, params.UpdatedAt, params.Vin, params.Year)
	var item UpdateVehicleRow
	if err := row.Scan(&item.ID, &item.CreatedAt, &item.UpdatedAt, &item.Make, &item.Model, &item.Year, &item.Vin); err != nil {
		return item, fmt.Errorf("query UpdateVehicle: %w", err)
	}
	return item, nil
}

const updateVehicleFieldMaskSQL = `UPDATE public.vehicle
SET (
	created_at,
	id,
	make,
	model,
	updated_at,
	vin,
	year
) = (
	CASE
		WHEN 'created_at' = ANY($1::text[]) THEN $2
		ELSE created_at
	END,
	CASE
		WHEN 'id' = ANY($1::text[]) THEN $3
		ELSE id
	END,
	CASE
		WHEN 'make' = ANY($1::text[]) THEN $4
		ELSE make
	END,
	CASE
		WHEN 'model' = ANY($1::text[]) THEN $5
		ELSE model
	END,
	CASE
		WHEN 'updated_at' = ANY($1::text[]) THEN $6
		ELSE updated_at
	END,
	CASE
		WHEN 'vin' = ANY($1::text[]) THEN $7
		ELSE vin
	END,
	CASE
		WHEN 'year' = ANY($1::text[]) THEN $8
		ELSE year
	END
) WHERE id = $3 RETURNING *;`

type UpdateVehicleFieldMaskParams struct {
	FieldMask []string   `json:"_field_mask"`
	CreatedAt *time.Time `json:"created_at"`
	ID        uuid.UUID  `json:"id"`
	Make      uuid.UUID  `json:"make"`
	Model     uuid.UUID  `json:"model"`
	UpdatedAt *time.Time `json:"updated_at"`
	Vin       *string    `json:"vin"`
	Year      int32      `json:"year"`
}

type UpdateVehicleFieldMaskRow struct {
	ID        uuid.UUID  `json:"id"`
	CreatedAt *time.Time `json:"created_at"`
	UpdatedAt *time.Time `json:"updated_at"`
	Make      uuid.UUID  `json:"make"`
	Model     uuid.UUID  `json:"model"`
	Year      int32      `json:"year"`
	Vin       *string    `json:"vin"`
}

// UpdateVehicleFieldMask implements Querier.UpdateVehicleFieldMask.
func (q *DBQuerier) UpdateVehicleFieldMask(ctx context.Context, params UpdateVehicleFieldMaskParams) (UpdateVehicleFieldMaskRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateVehicleFieldMask")
	row := q.conn.QueryRow(ctx, updateVehicleFieldMaskSQL, params.FieldMask, params.CreatedAt, params.ID, params.Make, params.Model, params.UpdatedAt, params.Vin, params.Year)
	var item UpdateVehicleFieldMaskRow
	if err := row.Scan(&item.ID, &item.CreatedAt, &item.UpdatedAt, &item.Make, &item.Model, &item.Year, &item.Vin); err != nil {
		return item, fmt.Errorf("query UpdateVehicleFieldMask: %w", err)
	}
	return item, nil
}

const updateModelSQL = `UPDATE public.model
SET (
	created_at,
	id,
	name,
	updated_at
) = (
	$1,
	$2,
	$3,
	$4
) WHERE id = $2 RETURNING *;`

type UpdateModelParams struct {
	CreatedAt *time.Time `json:"created_at"`
	ID        uuid.UUID  `json:"id"`
	Name      *string    `json:"name"`
	UpdatedAt *time.Time `json:"updated_at"`
}

type UpdateModelRow struct {
	ID        uuid.UUID  `json:"id"`
	Name      *string    `json:"name"`
	CreatedAt *time.Time `json:"created_at"`
	UpdatedAt *time.Time `json:"updated_at"`
}

// UpdateModel implements Querier.UpdateModel.
func (q *DBQuerier) UpdateModel(ctx context.Context, params UpdateModelParams) (UpdateModelRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateModel")
	row := q.conn.QueryRow(ctx, updateModelSQL, params.CreatedAt, params.ID, params.Name, params.UpdatedAt)
	var item UpdateModelRow
	if err := row.Scan(&item.ID, &item.Name, &item.CreatedAt, &item.UpdatedAt); err != nil {
		return item, fmt.Errorf("query UpdateModel: %w", err)
	}
	return item, nil
}

const updateModelFieldMaskSQL = `UPDATE public.model
SET (
	created_at,
	id,
	name,
	updated_at
) = (
	CASE
		WHEN 'created_at' = ANY($1::text[]) THEN $2
		ELSE created_at
	END,
	CASE
		WHEN 'id' = ANY($1::text[]) THEN $3
		ELSE id
	END,
	CASE
		WHEN 'name' = ANY($1::text[]) THEN $4
		ELSE name
	END,
	CASE
		WHEN 'updated_at' = ANY($1::text[]) THEN $5
		ELSE updated_at
	END
) WHERE id = $3 RETURNING *;`

type UpdateModelFieldMaskParams struct {
	FieldMask []string   `json:"_field_mask"`
	CreatedAt *time.Time `json:"created_at"`
	ID        uuid.UUID  `json:"id"`
	Name      *string    `json:"name"`
	UpdatedAt *time.Time `json:"updated_at"`
}

type UpdateModelFieldMaskRow struct {
	ID        uuid.UUID  `json:"id"`
	Name      *string    `json:"name"`
	CreatedAt *time.Time `json:"created_at"`
	UpdatedAt *time.Time `json:"updated_at"`
}

// UpdateModelFieldMask implements Querier.UpdateModelFieldMask.
func (q *DBQuerier) UpdateModelFieldMask(ctx context.Context, params UpdateModelFieldMaskParams) (UpdateModelFieldMaskRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateModelFieldMask")
	row := q.conn.QueryRow(ctx, updateModelFieldMaskSQL, params.FieldMask, params.CreatedAt, params.ID, params.Name, params.UpdatedAt)
	var item UpdateModelFieldMaskRow
	if err := row.Scan(&item.ID, &item.Name, &item.CreatedAt, &item.UpdatedAt); err != nil {
		return item, fmt.Errorf("query UpdateModelFieldMask: %w", err)
	}
	return item, nil
}

const updatePersonSQL = `UPDATE public.person
SET (
	created_at,
	id,
	name,
	updated_at
) = (
	$1,
	$2,
	$3,
	$4
) WHERE id = $2 RETURNING *;`

type UpdatePersonParams struct {
	CreatedAt *time.Time `json:"created_at"`
	ID        uuid.UUID  `json:"id"`
	Name      *string    `json:"name"`
	UpdatedAt *time.Time `json:"updated_at"`
}

type UpdatePersonRow struct {
	ID        uuid.UUID  `json:"id"`
	Name      *string    `json:"name"`
	CreatedAt *time.Time `json:"created_at"`
	UpdatedAt *time.Time `json:"updated_at"`
}

// UpdatePerson implements Querier.UpdatePerson.
func (q *DBQuerier) UpdatePerson(ctx context.Context, params UpdatePersonParams) (UpdatePersonRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdatePerson")
	row := q.conn.QueryRow(ctx, updatePersonSQL, params.CreatedAt, params.ID, params.Name, params.UpdatedAt)
	var item UpdatePersonRow
	if err := row.Scan(&item.ID, &item.Name, &item.CreatedAt, &item.UpdatedAt); err != nil {
		return item, fmt.Errorf("query UpdatePerson: %w", err)
	}
	return item, nil
}

const updatePersonFieldMaskSQL = `UPDATE public.person
SET (
	created_at,
	id,
	name,
	updated_at
) = (
	CASE
		WHEN 'created_at' = ANY($1::text[]) THEN $2
		ELSE created_at
	END,
	CASE
		WHEN 'id' = ANY($1::text[]) THEN $3
		ELSE id
	END,
	CASE
		WHEN 'name' = ANY($1::text[]) THEN $4
		ELSE name
	END,
	CASE
		WHEN 'updated_at' = ANY($1::text[]) THEN $5
		ELSE updated_at
	END
) WHERE id = $3 RETURNING *;`

type UpdatePersonFieldMaskParams struct {
	FieldMask []string   `json:"_field_mask"`
	CreatedAt *time.Time `json:"created_at"`
	ID        uuid.UUID  `json:"id"`
	Name      *string    `json:"name"`
	UpdatedAt *time.Time `json:"updated_at"`
}

type UpdatePersonFieldMaskRow struct {
	ID        uuid.UUID  `json:"id"`
	Name      *string    `json:"name"`
	CreatedAt *time.Time `json:"created_at"`
	UpdatedAt *time.Time `json:"updated_at"`
}

// UpdatePersonFieldMask implements Querier.UpdatePersonFieldMask.
func (q *DBQuerier) UpdatePersonFieldMask(ctx context.Context, params UpdatePersonFieldMaskParams) (UpdatePersonFieldMaskRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdatePersonFieldMask")
	row := q.conn.QueryRow(ctx, updatePersonFieldMaskSQL, params.FieldMask, params.CreatedAt, params.ID, params.Name, params.UpdatedAt)
	var item UpdatePersonFieldMaskRow
	if err := row.Scan(&item.ID, &item.Name, &item.CreatedAt, &item.UpdatedAt); err != nil {
		return item, fmt.Errorf("query UpdatePersonFieldMask: %w", err)
	}
	return item, nil
}

const updateRentalSQL = `UPDATE public.rental
SET (
	created_at,
	end_date,
	id,
	start_date,
	updated_at,
	vehicle
) = (
	$1,
	$2,
	$3,
	$4,
	$5,
	$6
) WHERE id = $3 RETURNING *;`

type UpdateRentalParams struct {
	CreatedAt *time.Time `json:"created_at"`
	EndDate   *time.Time `json:"end_date"`
	ID        uuid.UUID  `json:"id"`
	StartDate *time.Time `json:"start_date"`
	UpdatedAt *time.Time `json:"updated_at"`
	Vehicle   uuid.UUID  `json:"vehicle"`
}

type UpdateRentalRow struct {
	ID        uuid.UUID  `json:"id"`
	CreatedAt *time.Time `json:"created_at"`
	UpdatedAt *time.Time `json:"updated_at"`
	Vehicle   uuid.UUID  `json:"vehicle"`
	StartDate *time.Time `json:"start_date"`
	EndDate   *time.Time `json:"end_date"`
}

// UpdateRental implements Querier.UpdateRental.
func (q *DBQuerier) UpdateRental(ctx context.Context, params UpdateRentalParams) (UpdateRentalRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateRental")
	row := q.conn.QueryRow(ctx, updateRentalSQL, params.CreatedAt, params.EndDate, params.ID, params.StartDate, params.UpdatedAt, params.Vehicle)
	var item UpdateRentalRow
	if err := row.Scan(&item.ID, &item.CreatedAt, &item.UpdatedAt, &item.Vehicle, &item.StartDate, &item.EndDate); err != nil {
		return item, fmt.Errorf("query UpdateRental: %w", err)
	}
	return item, nil
}

const updateRentalFieldMaskSQL = `UPDATE public.rental
SET (
	created_at,
	end_date,
	id,
	start_date,
	updated_at,
	vehicle
) = (
	CASE
		WHEN 'created_at' = ANY($1::text[]) THEN $2
		ELSE created_at
	END,
	CASE
		WHEN 'end_date' = ANY($1::text[]) THEN $3
		ELSE end_date
	END,
	CASE
		WHEN 'id' = ANY($1::text[]) THEN $4
		ELSE id
	END,
	CASE
		WHEN 'start_date' = ANY($1::text[]) THEN $5
		ELSE start_date
	END,
	CASE
		WHEN 'updated_at' = ANY($1::text[]) THEN $6
		ELSE updated_at
	END,
	CASE
		WHEN 'vehicle' = ANY($1::text[]) THEN $7
		ELSE vehicle
	END
) WHERE id = $4 RETURNING *;`

type UpdateRentalFieldMaskParams struct {
	FieldMask []string   `json:"_field_mask"`
	CreatedAt *time.Time `json:"created_at"`
	EndDate   *time.Time `json:"end_date"`
	ID        uuid.UUID  `json:"id"`
	StartDate *time.Time `json:"start_date"`
	UpdatedAt *time.Time `json:"updated_at"`
	Vehicle   uuid.UUID  `json:"vehicle"`
}

type UpdateRentalFieldMaskRow struct {
	ID        uuid.UUID  `json:"id"`
	CreatedAt *time.Time `json:"created_at"`
	UpdatedAt *time.Time `json:"updated_at"`
	Vehicle   uuid.UUID  `json:"vehicle"`
	StartDate *time.Time `json:"start_date"`
	EndDate   *time.Time `json:"end_date"`
}

// UpdateRentalFieldMask implements Querier.UpdateRentalFieldMask.
func (q *DBQuerier) UpdateRentalFieldMask(ctx context.Context, params UpdateRentalFieldMaskParams) (UpdateRentalFieldMaskRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateRentalFieldMask")
	row := q.conn.QueryRow(ctx, updateRentalFieldMaskSQL, params.FieldMask, params.CreatedAt, params.EndDate, params.ID, params.StartDate, params.UpdatedAt, params.Vehicle)
	var item UpdateRentalFieldMaskRow
	if err := row.Scan(&item.ID, &item.CreatedAt, &item.UpdatedAt, &item.Vehicle, &item.StartDate, &item.EndDate); err != nil {
		return item, fmt.Errorf("query UpdateRentalFieldMask: %w", err)
	}
	return item, nil
}

const updateOwnershipSQL = `UPDATE public.ownership
SET (
	created_at,
	end_date,
	id,
	person,
	start_date,
	updated_at,
	vehicle
) = (
	$1,
	$2,
	$3,
	$4,
	$5,
	$6,
	$7
) WHERE id = $3 RETURNING *;`

type UpdateOwnershipParams struct {
	CreatedAt *time.Time `json:"created_at"`
	EndDate   *time.Time `json:"end_date"`
	ID        uuid.UUID  `json:"id"`
	Person    uuid.UUID  `json:"person"`
	StartDate *time.Time `json:"start_date"`
	UpdatedAt *time.Time `json:"updated_at"`
	Vehicle   uuid.UUID  `json:"vehicle"`
}

type UpdateOwnershipRow struct {
	ID        uuid.UUID  `json:"id"`
	CreatedAt *time.Time `json:"created_at"`
	UpdatedAt *time.Time `json:"updated_at"`
	Person    uuid.UUID  `json:"person"`
	Vehicle   uuid.UUID  `json:"vehicle"`
	StartDate *time.Time `json:"start_date"`
	EndDate   *time.Time `json:"end_date"`
}

// UpdateOwnership implements Querier.UpdateOwnership.
func (q *DBQuerier) UpdateOwnership(ctx context.Context, params UpdateOwnershipParams) (UpdateOwnershipRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateOwnership")
	row := q.conn.QueryRow(ctx, updateOwnershipSQL, params.CreatedAt, params.EndDate, params.ID, params.Person, params.StartDate, params.UpdatedAt, params.Vehicle)
	var item UpdateOwnershipRow
	if err := row.Scan(&item.ID, &item.CreatedAt, &item.UpdatedAt, &item.Person, &item.Vehicle, &item.StartDate, &item.EndDate); err != nil {
		return item, fmt.Errorf("query UpdateOwnership: %w", err)
	}
	return item, nil
}

const updateOwnershipFieldMaskSQL = `UPDATE public.ownership
SET (
	created_at,
	end_date,
	id,
	person,
	start_date,
	updated_at,
	vehicle
) = (
	CASE
		WHEN 'created_at' = ANY($1::text[]) THEN $2
		ELSE created_at
	END,
	CASE
		WHEN 'end_date' = ANY($1::text[]) THEN $3
		ELSE end_date
	END,
	CASE
		WHEN 'id' = ANY($1::text[]) THEN $4
		ELSE id
	END,
	CASE
		WHEN 'person' = ANY($1::text[]) THEN $5
		ELSE person
	END,
	CASE
		WHEN 'start_date' = ANY($1::text[]) THEN $6
		ELSE start_date
	END,
	CASE
		WHEN 'updated_at' = ANY($1::text[]) THEN $7
		ELSE updated_at
	END,
	CASE
		WHEN 'vehicle' = ANY($1::text[]) THEN $8
		ELSE vehicle
	END
) WHERE id = $4 RETURNING *;`

type UpdateOwnershipFieldMaskParams struct {
	FieldMask []string   `json:"_field_mask"`
	CreatedAt *time.Time `json:"created_at"`
	EndDate   *time.Time `json:"end_date"`
	ID        uuid.UUID  `json:"id"`
	Person    uuid.UUID  `json:"person"`
	StartDate *time.Time `json:"start_date"`
	UpdatedAt *time.Time `json:"updated_at"`
	Vehicle   uuid.UUID  `json:"vehicle"`
}

type UpdateOwnershipFieldMaskRow struct {
	ID        uuid.UUID  `json:"id"`
	CreatedAt *time.Time `json:"created_at"`
	UpdatedAt *time.Time `json:"updated_at"`
	Person    uuid.UUID  `json:"person"`
	Vehicle   uuid.UUID  `json:"vehicle"`
	StartDate *time.Time `json:"start_date"`
	EndDate   *time.Time `json:"end_date"`
}

// UpdateOwnershipFieldMask implements Querier.UpdateOwnershipFieldMask.
func (q *DBQuerier) UpdateOwnershipFieldMask(ctx context.Context, params UpdateOwnershipFieldMaskParams) (UpdateOwnershipFieldMaskRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateOwnershipFieldMask")
	row := q.conn.QueryRow(ctx, updateOwnershipFieldMaskSQL, params.FieldMask, params.CreatedAt, params.EndDate, params.ID, params.Person, params.StartDate, params.UpdatedAt, params.Vehicle)
	var item UpdateOwnershipFieldMaskRow
	if err := row.Scan(&item.ID, &item.CreatedAt, &item.UpdatedAt, &item.Person, &item.Vehicle, &item.StartDate, &item.EndDate); err != nil {
		return item, fmt.Errorf("query UpdateOwnershipFieldMask: %w", err)
	}
	return item, nil
}

// textPreferrer wraps a pgtype.ValueTranscoder and sets the preferred encoding
// format to text instead binary (the default). pggen uses the text format
// when the OID is unknownOID because the binary format requires the OID.
// Typically occurs if the results from QueryAllDataTypes aren't passed to
// NewQuerierConfig.
type textPreferrer struct {
	pgtype.ValueTranscoder
	typeName string
}

// PreferredParamFormat implements pgtype.ParamFormatPreferrer.
func (t textPreferrer) PreferredParamFormat() int16 { return pgtype.TextFormatCode }

func (t textPreferrer) NewTypeValue() pgtype.Value {
	return textPreferrer{ValueTranscoder: pgtype.NewValue(t.ValueTranscoder).(pgtype.ValueTranscoder), typeName: t.typeName}
}

func (t textPreferrer) TypeName() string {
	return t.typeName
}

// unknownOID means we don't know the OID for a type. This is okay for decoding
// because pgx call DecodeText or DecodeBinary without requiring the OID. For
// encoding parameters, pggen uses textPreferrer if the OID is unknown.
const unknownOID = 0
