package main

import (
	"context"
	"fmt"
	"io"
	"log"
	"os"
	"os/signal"
	"syscall"
	"text/template"

	"github.com/jackc/pgx/v4/pgxpool"
	"github.com/parrotmac/pginspector/models"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

type Relation struct {
	Forward bool
	Table   *Table
	Column  *Column
}

type Column struct {
	Name     string
	PGType   string
	Nullable bool
	Default  string
	Relation Relation
}

type Table struct {
	Schema       string
	Name         string
	Columns      []Column
	ProtoName    string
	PKColumnName string
}

func (t *Table) PrettyPrint() {
	fmt.Printf("Table: %s.%s\n", t.Schema, t.Name)
	for _, c := range t.Columns {
		fmt.Printf("\t%s: %s (default=%s) (nullable=%t) (relation:=%+v)\n", c.Name, c.PGType, c.Default, c.Nullable, c.Relation)
	}
}

type Schema struct {
	Tables map[string]Table
}

func Unwrap[T any](p *T) T {
	if p == nil {
		v := new(T)
		return *v
	}
	return *p
}

func (s *Schema) ProcessRow(schemaName string, tableName string, col Column) {
	if _, ok := s.Tables[tableName]; !ok {
		s.Tables[tableName] = Table{
			Schema:       schemaName,
			Name:         tableName,
			Columns:      []Column{},
			PKColumnName: "id",
		}
	}

	t := s.Tables[tableName]
	t.Columns = append(t.Columns, col)
	s.Tables[tableName] = t
}

func main() {
	ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
	defer stop()

	dbURL := os.Getenv("DATABASE_URL")
	if dbURL == "" {
		dbURL = "postgres://postgres:postgres@localhost:54322/postgres?sslmode=disable"
	}

	sch, err := inspectTablesInSchema(ctx, "public", dbURL)
	if err != nil {
		log.Fatal(err)
	}

	tableProtoMap := map[string]string{
		"person":       "v1.Person",
		"vehicle":      "v1.Vehcile",
		"model":        "v1.Model",
		"manufacturer": "v1.Manufacturer",
		"rental":       "v1.Rental",
		"ownership":    "v1.Ownership",
	}

	allTables := []Table{}
	for _, t := range sch.Tables {
		t.ProtoName, _ = tableProtoMap[t.Name]
		allTables = append(allTables, t)
	}

	err = os.MkdirAll("validation", 0755)
	if err != nil {
		log.Fatalf("Unable to create validation directory: %v\n", err)
	}

	outputFile, err := os.Create("validation/generated_queries.sql")
	if err != nil {
		log.Fatalf("Unable to create output file: %v\n", err)
	}

	fmt.Fprintf(outputFile, "-- This file is generated by pginspector. DO NOT EDIT.\n\n")

	err = generateGetAndListQueries(ctx, outputFile, allTables)
	if err != nil {
		log.Fatalf("Unable to generate get and list queries: %v\n", err)
	}

	err = generateUpdateQueries(ctx, outputFile, allTables)
	if err != nil {
		log.Fatalf("Unable to generate update queries: %v\n", err)
	}
}

func generateGetAndListQueries(ctx context.Context, w io.WriteCloser, tables []Table) error {
	tmpl, err := template.New("SQLGetAndListQueries").Funcs(template.FuncMap{
		"TitleCase": cases.Title(language.English).String,
	}).Parse(`{{- define "SQLGetAndListQueries" -}}
{{- range . }}

-- name: Select{{ TitleCase .Name }}ByID :one {{- if .ProtoName }} proto-type={{ .ProtoName }} {{- end }}
SELECT
	{{- range $index, $col := .Columns }}
	{{- if $index}},{{ end }}
	{{ $col.Name }}
	{{- end }}
FROM {{ .Schema }}.{{ .Name }}
WHERE {{ .PKColumnName }} = pggen.arg('{{ .PKColumnName }}');

-- name: Select{{ TitleCase .Name }}List :many {{- if .ProtoName }} proto-type={{ .ProtoName }} {{- end }}
SELECT
	{{- range $index, $col := .Columns }}
	{{- if $index}},{{ end }}
	{{ $col.Name }}
	{{- end }}
FROM {{ .Schema }}.{{ .Name }};

{{- end }}
{{- end }}
`)
	if err != nil {
		return err
	}

	return tmpl.Execute(w, tables)
}

func generateUpdateQueries(ctx context.Context, w io.WriteCloser, tables []Table) error {
	tmpl, err := template.New("SQLUpdateQueries").Funcs(template.FuncMap{
		"TitleCase": cases.Title(language.English).String,
	}).Parse(`{{- define "SQLUpdateQueries" -}}
{{- range . }}

-- name: Update{{ TitleCase .Name }} :one {{- if .ProtoName }} proto-type={{ .ProtoName }} {{- end }}
UPDATE {{ .Schema }}.{{ .Name }}
SET (
{{- range $index, $col := .Columns }}
	{{- if $index}},{{ end }}
	{{ $col.Name }}
	{{- end }}
) = (
{{- range $index, $col := .Columns }}
	{{- if $index}},{{ end }}
	pggen.arg('{{ $col.Name }}')
	{{- end }}
) WHERE {{ .PKColumnName }} = pggen.arg('{{ .PKColumnName }}') RETURNING *;

-- name: Update{{ TitleCase .Name }}FieldMask :one {{- if .ProtoName }} proto-type={{ .ProtoName }} {{- end }}
UPDATE {{ .Schema }}.{{ .Name }}
SET (
{{- range $index, $col := .Columns }}
	{{- if $index}},{{ end }}
	{{ $col.Name }}
	{{- end }}
) = (
{{- range $index, $col := .Columns }}
	{{- if $index}},{{ end }}
	CASE
		WHEN '{{ $col.Name }}' = ANY(pggen.arg('_field_mask')::text[]) THEN pggen.arg('{{ $col.Name }}')
		ELSE {{ $col.Name }}
	END
	{{- end }}
) WHERE {{ .PKColumnName }} = pggen.arg('{{ .PKColumnName }}') RETURNING *;

{{- end }}
{{- end }}`)
	if err != nil {
		return err
	}
	return tmpl.Execute(w, tables)
}

func inspectTablesInSchema(ctx context.Context, name string, dbConnectionString string) (Schema, error) {
	pgxConfig, err := pgxpool.ParseConfig(dbConnectionString)
	if err != nil {
		log.Fatalf("Unable to parse DATABASE_URL: %v\n", err)
	}
	pool, err := pgxpool.ConnectConfig(ctx, pgxConfig)
	if err != nil {
		log.Fatalf("Unable to create connection pool: %v\n", err)
	}

	querier := models.NewQuerier(pool)

	tablesAndColumns, err := querier.ListTableColumnsInSchema(ctx, "public")
	if err != nil {
		log.Fatal(err)
	}

	sch := Schema{
		Tables: map[string]Table{},
	}

	for _, col := range tablesAndColumns {
		sch.ProcessRow("public", col.TableName, Column{
			Name:     col.ColumnName,
			PGType:   Unwrap(col.DataType),
			Nullable: Unwrap(col.IsNullable) == "YES",
			Default:  Unwrap(col.ColumnDefault),
		})
	}

	for _, t := range sch.Tables {
		t.PrettyPrint()
	}

	return sch, nil
}
